<html><head><title>CollectingTokens</title></head><body  ><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><p>
Surya has a tree with n nodes, numbered 1 through n.
Each node contains some arbitrary nonnegative number of tokens.
</p>
<p></p>
<p>
Surya sometimes goes for a walk on the tree.
He has to start his walk in node 1, but he may terminate it in any node of the tree.
Surya gets tired easily: during the walk he is only able to traverse at most <b>L</b> edges.
</p>
<p></p>
<p>
Surya now wants to collect as many tokens as possible during a single walk.
He can collect tokens in all nodes he visits, including the nodes where he starts and ends his walk.
Obviously, the tokens in each node can only be collected once.
</p>
<p></p>
<p>
You are given the structure of the tree in int[]s <b>A</b> and <b>B</b>, each with n-1 elements.
For each valid i the tree contains an edge between the nodes <b>A</b>[i] and <b>B</b>[i].
You are also given the int[] <b>tokens</b> with n elements.
For each valid i, <b>tokens</b>[i] is the number of tokens in node i+1.
Finally, you are given the int <b>L</b>.
</p>
<p></p>
<p>
Return the maximum number of tokens Surya can collect.
</p></td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>CollectingTokens</td></tr><tr><td>Method:</td><td>maxTokens</td></tr><tr><td>Parameters:</td><td>int[], int[], int[], int</td></tr><tr><td>Returns:</td><td>int</td></tr><tr><td>Method signature:</td><td>int maxTokens(int[] A, int[] B, int[] tokens, int L)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td>n will be between 1 and 50, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>A</b> and <b>B</b> will contain exactly n-1 elements each.</td></tr><tr><td align="center" valign="top">-</td><td>Each element of <b>A</b> and <b>B</b> will be between 1 and n, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>A</b> and <b>B</b> will define a tree.</td></tr><tr><td align="center" valign="top">-</td><td><b>tokens</b> will contain exactly n elements.</td></tr><tr><td align="center" valign="top">-</td><td>Each element of <b>tokens</b> will be between 1 and 100, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>L</b> will be between 1 and 100, inclusive.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1}</pre></td></tr><tr><td><pre>{2}</pre></td></tr><tr><td><pre>{7,1}</pre></td></tr><tr><td><pre>6</pre></td></tr></table></td></tr><tr><td><pre>Returns: 8</pre></td></tr><tr><td><table><tr><td colspan="2">This tree consists of two nodes and a single edge.
There are 7 tokens in node 1 and 1 token in node 2.
Surya can make at most six steps, which is more than enough to collect all 7+1 = 8 tokens.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{3,1}</pre></td></tr><tr><td><pre>{2,2}</pre></td></tr><tr><td><pre>{2,3,9}</pre></td></tr><tr><td><pre>5</pre></td></tr></table></td></tr><tr><td><pre>Returns: 14</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1,2,5,3}</pre></td></tr><tr><td><pre>{4,4,1,4}</pre></td></tr><tr><td><pre>{6,1,6,4,4}</pre></td></tr><tr><td><pre>3</pre></td></tr></table></td></tr><tr><td><pre>Returns: 16</pre></td></tr><tr><td><table><tr><td colspan="2">This is a tree with five nodes.
One optimal walk for this tree is to start in node 1, go to node 4, then to node 3, and then back to node 4.
As <b>L</b>=3, this is the longest walk Surya may make.
During this walk he will collect 6 tokens in node 1, 4 tokens in node 4, 6 tokens in node 3, and then 0 tokens when revisiting node 4.
The total is 6+4+6+0 = 16 tokens.

Another optimal walk is to start in node 1, go to node 4, then to node 3, and to stop there.
Surya is not required to make all <b>L</b> steps.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{9,1,7,10,5,8,3,4,2}</pre></td></tr><tr><td><pre>{6,6,9,6,6,1,1,6,6}</pre></td></tr><tr><td><pre>{4,2,1,6,3,7,8,5,2,9}</pre></td></tr><tr><td><pre>4</pre></td></tr></table></td></tr><tr><td><pre>Returns: 26</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{25,22,35,42,40,9,32,12,37,44,23,1,24,28,20,4,26,33,11,48,34,6,16,50,46,17,8,43,18,30,31,36,39,13,
10,45,3,47,15,2,29,19,7,14,41,49,38,27,21}</pre></td></tr><tr><td><pre>{5,5,25,25,25,42,25,40,5,35,25,32,42,9,32,23,40,25,20,33,26,37,12,1,48,24,22,25,11,24,48,34,18,9,50,42,16,40,1,
10,47,22,48,44,48,1,4,46,47}</pre></td></tr><tr><td><pre>{6,9,4,9,5,8,6,4,4,1,4,8,3,4,5,8,5,6,4,9,7,9,7,9,5,2,7,2,7,7,5,9,5,8,5,7,1,9,3,9,3,6,4,5,5,4,7,9,2,2}</pre></td></tr><tr><td><pre>48</pre></td></tr></table></td></tr><tr><td><pre>Returns: 194</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>